{-# OPTIONS_GHC -Wno-deprecations #-}
module Main where

import Options.Applicative
import "protolude" Protolude hiding (find)
import qualified "turtle" Turtle
import "turtle" Turtle ((</>))
import qualified "directory" System.Directory
import qualified "filepath" System.FilePath
import "base" Data.String (String)
import qualified "base" Data.String as String
import qualified "base" Data.List as List
import qualified Data.List.Index as List
import qualified "text" Data.Text as Text
import qualified Data.List.NonEmpty (NonEmpty)
import qualified Data.List.NonEmpty as NonEmpty
import qualified "directory-tree" System.Directory.Tree
import "directory-tree" System.Directory.Tree (DirTree (..), AnchoredDirTree (..))
import qualified "cases" Cases
import Control.Concurrent.Async
import Control.Monad.Writer
import CssContentToTypes
import "non-empty-text" Data.NonEmptyText (NonEmptyText)
import qualified "non-empty-text" Data.NonEmptyText as NonEmptyText

import AppOptions
import Control.Concurrent.Async
import Control.Monad.Writer
import Logger
import ModuleName
import Text.Colour.Chunk (Chunk)
import UpdateModuleName
import Utils
import AppOptions
import Control.Concurrent.Async
import Control.Monad.Writer
import Data.String (fromString)
import Logger
import ModuleName
import Text.Colour.Chunk (Chunk)
import UpdateModuleName
import Utils
import qualified Text.Colour

appOptionsParserInfo :: ParserInfo GlobalAndCommandOptions
appOptionsParserInfo = info (globalAndCommandOptionsParser <**> helper)
  ( fullDesc
  <> progDesc "Halogen FFI generator for webpack css modules"
  <> header "Finds Anyname.module.css, generates Anyname.purs and Anyname.js files" )

main :: IO ()
main = do
  globalAndCommandOptions <- execParser appOptionsParserInfo

  let
    color = globalAndCommandOptions_color globalAndCommandOptions
    commandShort = commandOptionsToCommandShort $ globalAndCommandOptions_command globalAndCommandOptions
    targetDirectoriesOptions = commandOptionsToTargetDirectoriesOptions $ globalAndCommandOptions_command globalAndCommandOptions

  logger <- makeLogger color

  directoryConfig :: NonEmpty DirectoryConfig <- targetDirectoriesOptionsToDirectoryConfigOrCwd targetDirectoriesOptions

  let
    dirsThatRequiredToBePresent :: Maybe (NonEmpty Turtle.FilePath) = collectRequiredDirs directoryConfig

  mapM_ Utils.ensureDirsExist dirsThatRequiredToBePresent

  baseDirs :: NonEmpty (Turtle.FilePath, [Turtle.FilePath]) <-
    forConcurrently directoryConfig \config -> do
      let baseDir = directoryConfig_pathToDirectory config
      files <- Utils.findFilesWith Utils.isCssModuleFile baseDir
      pure (baseDir, files)

  withConcurrentLogger logger \concurrentLogger ->
    forConcurrently_ baseDirs \(baseDir, filePaths) ->
      forConcurrently_ filePaths \filePath -> do
        let
          log :: [Chunk] -> WriterT [[Chunk]] IO ()
          log x = tell [x]

          action :: WriterT [[Chunk]] IO ()
          action = do
            log
              [ Text.Colour.fore Text.Colour.green "processing ",
                Text.Colour.fore Text.Colour.yellow (fromString $ filePath)
              ]

            cssFileContent <- liftIO $ Turtle.readTextFile filePath

            let (classNames :: [Text]) = cssContentToTypes cssFileContent

            moduleName <- liftIO $ fullPathToModuleName baseDir filePath

            let
              moduleName_lastPart :: NonEmptyText = NonEmpty.last (unModuleName moduleName)

            let
              makeFile :: String -> Turtle.FilePath
              makeFile ext =
                Turtle.directory filePath
                  Turtle.</>
                  Turtle.decodeString (toS $ NonEmptyText.toText moduleName_lastPart)
                  Turtle.<.>
                  ext
              jsFilePath = makeFile "js"
              pursFilePath = makeFile "purs"

            log [Text.Colour.fore Text.Colour.blue "  writing ", Text.Colour.fore Text.Colour.red (fromString jsFilePath)]
            log [Text.Colour.fore Text.Colour.blue "  writing ", Text.Colour.fore Text.Colour.red (fromString pursFilePath)]

            liftIO $ Turtle.writeTextFile jsFilePath
              ( Text.unlines
                [ "// Do not edit, this file was autogenerated by     generate-halogen-css-modules"
                , "exports.styles = require('./" <> toS (Turtle.encodeString (Turtle.filename filePath)) <> "').default"
                ]
              )
            liftIO $ Turtle.writeTextFile pursFilePath
              ( let
                  imports = Text.unlines $ List.imap (\(index) (className ::    Text) -> (if index == 0 then "  { " else "  , ") <>   className  <> " :: ClassName") classNames
                  styles =
                    if List.length classNames == 0
                      then "foreign import styles :: {}"
                      else "foreign import styles ::\n" <> imports <> "  }"
                in Text.unlines
                  [ "-- Do not edit, this file was autogenerated by     generate-halogen-css-modules"
                  , "module " <> Text.intercalate "." (fmap NonEmptyText.toText $ NonEmpty.toList $ unModuleName moduleName) <> " (styles) where"
                  , ""
                  , "import Halogen.HTML (ClassName)"
                  , ""
                  , styles
                  ]
              )

        execWriterT action >>= (concurrentLogger Log . Text.Colour.unlinesChunks)
